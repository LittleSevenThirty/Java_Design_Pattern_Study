# 访问者模式

**访问者模式：**指将作用于某种数据结构中的个元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式

![访问者模式，图片来自 refactoringguru.cn](https://bugstack.cn/assets/images/2020/itstack-demo-design-22-01.png)

访问者要解决的核心事项是，在一个稳定的数据结构下，例如用户信息，雇员信息等，增加易变的业务访问逻辑，为了增强扩展性，将这两部分的业务解耦的一种设计模式

## 案例场景模拟

**在本案例中我们模拟校园中的学生和老师对于不同用户的访问视角**

这个案例场景我们模拟校园中有学生和老师两种身份的用户，那么对于家长和校长关心的角度来看，他们的视角是不同的。家长更关心孩子的成绩和老师的能力，校长更关心老师所在班级学生的人数和升学率{`此处模拟的`}。

那么这样`学生`和`老师`就是一个固定信息的内容，而想让不同视角的用户获取关心的信息，就比较适合使用访问者模式来实现，从而让实体与业务解耦，增强扩展性。**但访问者模式的整体类结构相对复杂，需要梳理清楚再开发**

**工程结构**

```cmd
itstack-demo-design-22-00
└── src
    ├── main
    │   └── java
    │       └── org.itstack.demo.design
    │           ├── user
    │           │	  ├── impl
    │           │	  │     ├── Student.java
    │           │	  │     └── Teacher.java
    │           │	  └── User.java   
    │           ├── visitor
    │           │	  ├── impl
    │           │	  │     ├── Parent.java
    │           │	  │     └── Principal.java
    │           │	  └── Visitor.java
    │           └──  DataView.java
    └── test
        └── java
            └── org.itstack.demo.design.test
                └── ApiTest.java
```

![访问者模式模型结构](https://bugstack.cn/assets/images/2020/itstack-demo-design-22-04.png)

在这里有一个关键的点非常重要，也就是整套设计模式的核心组成部分；`visitor.visit(this)`，这个方法在每一个用户实现类里，包括；`Student`、`Teacher`。在以下的实现中可以重点关注



- 从业务场景中可以看到，在嵌入访问者模式后，可以让整个工程结构变得容易添加和修改。也就做到了系统服务之间的解耦，不至于为了不同类型信息的访问而增加很多多余的`if`判断或者类的强制转换。也就是通过这样的设计模式而让代码结构更加清晰。
- 另外在实现的过程中你可能也发现了，定义抽象类的时候还需要等待访问者接口的定义，这样的设计首先从实现上会让代码的组织变得有些难度。另外从设计模式原则的角度来看，违背了迪米特原则，也就是最少知道原则。因此在使用上一定要符合场景的运用，以及提取这部分设计思想的精髓。