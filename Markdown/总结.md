# 总结

### ‌**设计模式分类总结**‌

分为三大类：‌**创建型**‌、‌**结构型**‌、‌**行为型**‌

------

### ‌**一、创建型模式（5种）**‌

‌**核心目标**‌：解耦对象创建过程，提高灵活性和复用性。

#### 1. 单例模式（Singleton）

- ‌**意图**‌：确保一个类只有一个实例，并提供全局访问点。

- ‌**结构**‌：私有构造函数 + 静态实例 + 静态获取方法。

- ‌**场景**‌：数据库连接池、日志系统、配置管理。

- ‌**关键点**：

  - 懒汉式（双重检查锁） vs 饿汉式。
  - 线程安全性和序列化问题。

- ‌**代码示例**：

  ```
  javaCopy Codepublic class Singleton {
      private static volatile Singleton instance;
      private Singleton() {}
      public static Singleton getInstance() {
          if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

#### 2. 工厂方法模式（Factory Method）

- ‌**意图**‌：定义一个创建对象的接口，由子类决定实例化哪个类。
- ‌**结构**‌：抽象工厂接口 + 具体工厂实现类。
- ‌**场景**‌：框架类库（如Spring的BeanFactory）、UI组件创建。
- ‌**优点**‌：扩展性好，新增产品只需新增工厂类。

#### 3. 抽象工厂模式（Abstract Factory）

- ‌**意图**‌：创建一系列相关或依赖对象的家族，而无需指定具体类。
- ‌**结构**‌：抽象工厂接口 + 多个产品族的实现。
- ‌**场景**‌：跨平台UI组件（Windows/Mac按钮/文本框）、游戏角色装备系统。
- ‌**与工厂方法的区别**‌：抽象工厂针对产品族，工厂方法针对单个产品等级。

#### 4. 建造者模式（Builder）

- ‌**意图**‌：分步骤创建复杂对象，允许灵活配置。
- ‌**结构**‌：Builder接口 + Director指导构建过程。
- ‌**场景**‌：创建包含多个组件的对象（如HTML文档生成器、订单系统）。

#### 5. 原型模式（Prototype）

- ‌**意图**‌：通过复制现有对象来创建新对象，避免重复初始化。
- ‌**结构**‌：实现`Cloneable`接口 + 重写`clone()`方法。
- ‌**场景**‌：对象初始化成本高（如数据库查询结果缓存）、游戏中的角色克隆。
- ‌**深拷贝 vs 浅拷贝**‌：需注意引用类型字段的复制。

------

### ‌**二、结构型模式（7种）**‌

‌**核心目标**‌：通过组合类和对象形成更大的结构。

#### 1. 适配器模式（Adapter）

- ‌**意图**‌：将不兼容的接口转换为客户端期望的接口。
- ‌**结构**‌：类适配器（继承）或对象适配器（组合）。
- ‌**场景**‌：旧系统接口改造（如JDBC驱动适配不同数据库）。

#### 2. 装饰器模式（Decorator）

- ‌**意图**‌：动态地为对象添加职责，避免继承导致的类爆炸。
- ‌**结构**‌：抽象组件 + 具体组件 + 装饰器基类。
- ‌**场景**‌：Java I/O流（如`BufferedInputStream`）、动态添加日志功能。

#### 3. 代理模式（Proxy）

- ‌**意图**‌：为对象提供代理以控制访问（延迟加载、权限控制等）。
- ‌**类型**‌：静态代理、动态代理（JDK/CGLib）、远程代理（RMI）。
- ‌**场景**‌：Spring AOP、图片懒加载、API请求缓存。

#### 4. 外观模式（Facade）

- ‌**意图**‌：为子系统提供统一入口，简化调用。
- ‌**场景**‌：API网关、微服务中的聚合服务。

#### 5. 组合模式（Composite）

- ‌**意图**‌：将对象组合成树形结构以表示“部分-整体”层次。
- ‌**场景**‌：文件系统目录结构、UI组件嵌套（如菜单树）。

------

### ‌**三、行为型模式（11种）**‌

‌**核心目标**‌：管理对象间的通信和职责分配。

#### 1. 观察者模式（Observer）

- ‌**意图**‌：定义对象间的一对多依赖关系，一个对象状态变化时自动通知依赖对象。
- ‌**结构**‌：Subject（主题） + Observer接口。
- ‌**场景**‌：事件驱动系统（如GUI按钮点击）、消息队列发布-订阅模型。
- ‌**对比**‌：与发布-订阅模式的区别（中间是否有Broker）。

#### 2. 策略模式（Strategy）

- ‌**意图**‌：定义一系列算法，封装每个算法并使它们可互换。
- ‌**结构**‌：策略接口 + 具体策略实现类 + Context上下文。
- ‌**场景**‌：支付方式选择（微信/支付宝）、排序算法动态切换。

#### 3. 模板方法模式（Template Method）

- ‌**意图**‌：定义算法骨架，允许子类重写某些步骤。
- ‌**结构**‌：抽象类定义模板方法 + 具体子类实现。
- ‌**场景**‌：工作流框架（如Spring的JdbcTemplate）、自动化测试步骤。

#### 4. 责任链模式（Chain of Responsibility）

- ‌**意图**‌：将请求沿着处理链传递，直到有对象处理它。
- ‌**场景**‌：审批流程（如请假审批）、Web过滤器链。

#### 5. 状态模式（State）

- ‌**意图**‌：允许对象在其内部状态改变时改变行为。
- ‌**场景**‌：订单状态流转（待支付/已发货/已完成）、游戏角色状态切换。

------

### ‌**四、常用模式对比表**‌

| 模式名称   | 核心思想         | 典型场景               | 使用频率 |
| ---------- | ---------------- | ---------------------- | -------- |
| 单例模式   | 全局唯一实例     | 配置管理、日志系统     | ⭐⭐⭐⭐⭐    |
| 工厂方法   | 子类决定对象创建 | 框架扩展、组件创建     | ⭐⭐⭐⭐     |
| 观察者模式 | 事件通知机制     | GUI事件、消息订阅      | ⭐⭐⭐⭐     |
| 策略模式   | 算法可互换       | 支付方式、排序策略     | ⭐⭐⭐⭐     |
| 代理模式   | 控制对象访问     | AOP、延迟加载          | ⭐⭐⭐⭐     |
| 装饰器模式 | 动态扩展功能     | Java I/O流、中间件增强 | ⭐⭐⭐      |
| 适配器模式 | 接口兼容转换     | 旧系统改造             | ⭐⭐⭐      |